给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.

与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).


int analysis(int x){
    if(x>=0)
    return x;
    else if(x<0)
    return -x;
}
int threeSumClosest(int* nums, int numsSize, int target){
    int answer=0;int target_new=0;int i=0;int j=0;int sum=0;
    for(int i=0;i<numsSize-1;i++){
        for(int j=i+1;j<numsSize;j++){
            if(nums[i]>nums[j]){
                int temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
            }
        }
    }
    answer=nums[0]+nums[1]+nums[numsSize-1];
    for(int k=0;k<numsSize-2;k++){
        i=k+1;
        j=numsSize-1;
        while(i<j){
            sum=nums[k]+nums[i]+nums[j];
            if(sum==target){
            target_new=target;break;}
            else if(sum>target){
                j--;sum=nums[k]+nums[i]+nums[j];
                if(sum<target){
                    target_new=((target-sum)>(nums[k]+nums[i]+nums[j+1]-target))? nums[k]+nums[i]+nums[j+1]:sum;
                break;}
            }
            else if(sum<target){
                i++;sum=nums[k]+nums[i]+nums[j];
                if(sum>target){
                    target_new=((sum-target)>(target-(nums[k]+nums[i-1]+nums[j])))? nums[k]+nums[i-1]+nums[j]:sum;
                break;}
            }
        }
        if(target_new==target){
            answer=target;
            break;
        }
        if(analysis(target-answer)>analysis(target-target_new))
        answer=target_new;
    }
    return answer;
}
